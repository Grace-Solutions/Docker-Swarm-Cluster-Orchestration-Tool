#!/bin/bash
# 001-PreInitialization.sh - Runs before service deployment
# Environment variables available:
#   STORAGE_MOUNT_PATH     - Base storage mount path (e.g., /mnt/MicroCephFS/docker-swarm-0001)
#   SERVICE_DATA_DIR       - Service data subdirectory name (e.g., "data")
#   SERVICE_DEFINITIONS_DIR- Service definitions subdirectory name (e.g., "ServiceDefinitions")
#   PRIMARY_MASTER         - Primary master node hostname
#   HAS_DEDICATED_WORKERS  - "true" if cluster has dedicated workers
#   DISTRIBUTED_STORAGE    - "true" if distributed storage is enabled
#   NODE_HOSTNAME          - This node's hostname
#   NGINXUI_ENABLED        - "true" if NginxUI service is enabled
#   NGINXUI_LB_NODES       - Comma-separated list of load balancer node hostnames
#   NGINXUI_CLUSTER_CONFIG_<HOSTNAME> - Per-node cluster config (base64, HOSTNAME uppercased, - replaced with _)

set -e

echo "[PreInit] Starting pre-initialization..."
echo "[PreInit] STORAGE_MOUNT_PATH: ${STORAGE_MOUNT_PATH}"
echo "[PreInit] DISTRIBUTED_STORAGE: ${DISTRIBUTED_STORAGE}"
echo "[PreInit] NODE_HOSTNAME: ${NODE_HOSTNAME}"

# Exit early if no storage path configured
if [ -z "${STORAGE_MOUNT_PATH}" ]; then
    echo "[PreInit] No storage mount path configured, skipping pre-initialization"
    exit 0
fi

BASE_PATH="${STORAGE_MOUNT_PATH}/${SERVICE_DATA_DIR}"

# =============================================================================
# NginxUI Pre-Initialization (Per-Node Directories)
# =============================================================================

# Function to create NginxUI directories for a single node
create_nginxui_node_dirs() {
    local hostname="$1"
    local nginxui_base="${BASE_PATH}/NginxUI/${hostname}"
    local nginx_path="${nginxui_base}/nginx"
    local nginxui_path="${nginxui_base}/nginxui"

    echo "[PreInit] Creating NginxUI directories for node: ${hostname}..."

    # Create all required directories for NginxUI self-check
    mkdir -p "${nginx_path}/conf.d"
    mkdir -p "${nginx_path}/sites-available"
    mkdir -p "${nginx_path}/sites-enabled"
    mkdir -p "${nginx_path}/streams-available"
    mkdir -p "${nginx_path}/streams-enabled"
    mkdir -p "${nginx_path}/logs"
    mkdir -p "${nginxui_path}"

    # Create empty log files if they don't exist (NginxUI checks these)
    touch "${nginx_path}/logs/access.log"
    touch "${nginx_path}/logs/error.log"

    # Download mime.types if not exists
    local mime_path="${nginx_path}/mime.types"
    if [ ! -f "${mime_path}" ]; then
        curl -sSL -o "${mime_path}" 'https://raw.githubusercontent.com/nginx/nginx/master/conf/mime.types' 2>/dev/null || true
    fi

    # Create nginx.conf if not exists
    local nginx_conf="${nginx_path}/nginx.conf"
    if [ ! -f "${nginx_conf}" ]; then
        cat > "${nginx_conf}" << 'NGINX_CONF_EOF'
user  nginx;
worker_processes  auto;

error_log  /etc/nginx/logs/error.log notice;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /etc/nginx/logs/access.log  main;

    sendfile        on;
    keepalive_timeout  65;

    # Include conf.d directory (NginxUI self-check)
    include /etc/nginx/conf.d/*.conf;

    # Include sites-enabled directory (NginxUI self-check)
    include /etc/nginx/sites-enabled/*;
}

# Include streams-enabled directory (NginxUI self-check)
stream {
    include /etc/nginx/streams-enabled/*;
}
NGINX_CONF_EOF
    fi

    # Create NginxUI reverse proxy config (access management UI at /nginxui/)
    local nginxui_proxy_conf="${nginx_path}/conf.d/nginxui-management.conf"
    cat > "${nginxui_proxy_conf}" << 'NGINXUI_PROXY_EOF'
# NginxUI Management Interface Reverse Proxy
# Access the NginxUI management interface at http://<host>/nginxui/
# Generated by dscotctl

server {
    listen 80 default_server;
    listen [::]:80 default_server;

    # NginxUI Management Interface
    location /nginxui/ {
        proxy_pass http://127.0.0.1:9000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_buffering off;
        proxy_read_timeout 86400;
    }

    # Default location - return 404 or customize as needed
    location / {
        return 404 "No site configured. Access NginxUI at /nginxui/\n";
        add_header Content-Type text/plain;
    }
}
NGINXUI_PROXY_EOF

    # Create/update app.ini with per-node cluster configuration
    # Each node gets config containing ONLY the other nodes (not itself)
    local app_ini="${nginxui_path}/app.ini"

    # Build env var name: NGINXUI_CLUSTER_CONFIG_<HOSTNAME> (uppercase, - replaced with _)
    local safe_hostname
    safe_hostname=$(echo "${hostname}" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
    local env_var_name="NGINXUI_CLUSTER_CONFIG_${safe_hostname}"
    local encoded_config="${!env_var_name}"

    if [ -n "${encoded_config}" ]; then
        # Decode base64 cluster config for this specific node
        local cluster_cfg
        cluster_cfg=$(echo "${encoded_config}" | base64 -d 2>/dev/null || echo "")
        if [ -n "${cluster_cfg}" ]; then
            echo "[PreInit] Writing app.ini for ${hostname} with cluster peers"
            cat > "${app_ini}" << APP_INI_EOF
# NginxUI Configuration - Generated by dscotctl
# Node: ${hostname}
# Cluster peers (other nodes this node syncs with):

[app]
PageSize = 10

[server]
HttpPort = 9000
RunMode = release

[nginx]
AccessLogPath = /etc/nginx/logs/access.log
ErrorLogPath = /etc/nginx/logs/error.log
ConfigDir = /etc/nginx
PIDPath = /var/run/nginx.pid
ReloadCmd = nginx -s reload
RestartCmd = nginx -s reopen

${cluster_cfg}
APP_INI_EOF
        fi
    elif [ ! -f "${app_ini}" ]; then
        echo "[PreInit] Writing basic app.ini for ${hostname} (no cluster peers)"
        cat > "${app_ini}" << 'APP_INI_EOF'
# NginxUI Configuration - Generated by dscotctl

[app]
PageSize = 10

[server]
HttpPort = 9000
RunMode = release

[nginx]
AccessLogPath = /etc/nginx/logs/access.log
ErrorLogPath = /etc/nginx/logs/error.log
ConfigDir = /etc/nginx
PIDPath = /var/run/nginx.pid
ReloadCmd = nginx -s reload
RestartCmd = nginx -s reopen
APP_INI_EOF
    fi

    echo "[PreInit] NginxUI directories ready for ${hostname}"
}

# Each node creates its OWN directory using its hostname
# Script runs on ALL nodes, each creates its own folder on shared (or local) storage
# Using case statement with never-matching case to ensure default always runs
case "${NODE_HOSTNAME}" in
    "__THIS_CASE_NEVER_MATCHES__")
        # This case intentionally never matches
        ;;
    *)
        # Default case - always runs, each node creates its own directory
        echo "[PreInit] Creating NginxUI directories for this node: ${NODE_HOSTNAME}"
        create_nginxui_node_dirs "${NODE_HOSTNAME}"
        ;;
esac

# =============================================================================
# Portainer Pre-Initialization
# =============================================================================
echo "[PreInit] Initializing Portainer..."

PORTAINER_PATH="${BASE_PATH}/Portainer"
mkdir -p "${PORTAINER_PATH}/data"
echo "[PreInit] Portainer directories created"

# =============================================================================
# Service Definitions Directory
# =============================================================================
echo "[PreInit] Creating ServiceDefinitions directory..."
mkdir -p "${STORAGE_MOUNT_PATH}/${SERVICE_DEFINITIONS_DIR}"
echo "[PreInit] ServiceDefinitions directory ready"

echo "[PreInit] âœ… Pre-initialization complete"

